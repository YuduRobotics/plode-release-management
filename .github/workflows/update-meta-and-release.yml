name: Update Meta and Create Firmware Release

on:
  push:
    branches:
      - main
    paths:
      - "**/*"

permissions:
  contents: write

jobs:
  update-meta:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: pip install pyyaml

      - name: Detect changed firmware folders and files
        id: detect
        run: |
          echo "Detecting changed firmware folders and files..."
          git diff --name-status HEAD~1 HEAD > /tmp/changed_files.txt || true
          cat /tmp/changed_files.txt || true

          # Filter top-level firmware directories
          > /tmp/firmware_folders.txt
          > /tmp/added_files.txt
          > /tmp/deleted_files.txt

          while read status path; do
            [ -z "$path" ] && continue
            top=$(echo "$path" | cut -d'/' -f1)

            # Ignore hidden/system root files
            case "$top" in
              .* | LICENSE | README* ) continue ;;
            esac

            # Categorize changes
            if [ "$status" = "D" ]; then
              echo "$path" >> /tmp/deleted_files.txt
            else
              echo "$path" >> /tmp/added_files.txt
            fi

            # Track valid top-level firmware dirs
            if [ -d "$top" ]; then
              echo "$top" >> /tmp/firmware_folders.txt
            else
              echo "deleted:$top" >> /tmp/firmware_folders.txt
            fi
          done < /tmp/changed_files.txt

          sort -u /tmp/firmware_folders.txt -o /tmp/firmware_folders.txt

          folders=$(grep -v '^deleted:' /tmp/firmware_folders.txt | tr '\n' ' ' || true)
          deleted=$(grep '^deleted:' /tmp/firmware_folders.txt | cut -d':' -f2 | tr '\n' ' ' || true)
          echo "folders=$folders" >> $GITHUB_OUTPUT
          echo "deleted=$deleted" >> $GITHUB_OUTPUT

      - name: Revert manual meta.yaml edits (protect metadata)
        run: |
          echo "Checking for manually edited meta.yaml files..."
          git diff --name-only HEAD~1 HEAD | grep "meta.yaml" || true

          edited_files=$(git diff --name-only HEAD~1 HEAD | grep "meta.yaml" || true)

          if [ -z "$edited_files" ]; then
            echo "No manual meta.yaml edits detected."
          else
            for file in $edited_files; do
              # Skip if this change was made by the bot
              author=$(git log -1 --pretty=format:'%an' -- "$file" || true)
              if [ "$author" != "github-actions[bot]" ]; then
                echo "Reverting unauthorized edit in $file"
                git checkout HEAD~1 -- "$file" || true
              fi
            done
          fi

      - name: Update meta.yaml files
        if: steps.detect.outputs.folders != ''
        env:
          FOLDERS: ${{ steps.detect.outputs.folders }}
        run: |
          import os, yaml, datetime, subprocess, sys

          folders = os.environ.get("FOLDERS", "").split()
          if not folders or folders == ['']:
              sys.exit(0)

          for folder in folders:
              if not os.path.isdir(folder):
                  print(f"Skipping {folder} (not a directory)")
                  continue

              meta_path = os.path.join(folder, "meta.yaml")
              data = {}

              if os.path.exists(meta_path):
                  with open(meta_path) as f:
                      data = yaml.safe_load(f) or {}

              version = float(data.get("version", 0))
              version = round(version + 0.1, 1)

              data.update({
                  "version": version,
                  "last_updated": datetime.datetime.utcnow().isoformat() + "Z",
                  "last_commit": subprocess.getoutput("git rev-parse HEAD"),
                  "folder": folder
              })

              with open(meta_path, "w") as f:
                  yaml.dump(data, f)

              print(f"Updated {meta_path} -> version {version}")

        shell: python

      - name: Commit and push updated meta.yaml (if any)
        run: |
          if ls */meta.yaml 1> /dev/null 2>&1; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add --all
            if git diff --cached --quiet; then
              echo "No changes to commit."
            else
              git commit -m "Auto-update meta.yaml"
              git push origin main
            fi
          else
            echo "No meta.yaml files found; skipping commit."
          fi

      - name: Create or update GitHub releases per firmware
        if: steps.detect.outputs.folders != ''
        env:
          FOLDERS: ${{ steps.detect.outputs.folders }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          for folder in $FOLDERS; do
            [ ! -d "$folder" ] && continue

            version=$(grep '^version:' "$folder/meta.yaml" | awk '{print $2}')
            tag="${folder}-v${version}"

            # Determine changed files inside this folder
            changed_files=$(git diff --name-only HEAD~1 HEAD | grep "^${folder}/" || true)

            if [ -z "$changed_files" ]; then
              files_to_upload="$folder/meta.yaml"
            else
              files_to_upload="$changed_files $folder/meta.yaml"
            fi

            if gh release view "$tag" >/dev/null 2>&1; then
              echo "Release exists; updating assets."
            else
              echo "Creating new release for $folder ($tag)"
              gh release create "$tag" --title "$folder v${version}" --notes "Automated release for $folder (v${version})." --target main
            fi

            echo "Uploading changed assets for $folder..."
            for f in $files_to_upload; do
              if [ -f "$f" ]; then
                gh release upload "$tag" "$f" --clobber || true
              fi
            done

            added=$(git diff --name-status HEAD~1 HEAD | grep "^A" | grep "$folder" || true)
            modified=$(git diff --name-status HEAD~1 HEAD | grep "^M" | grep "$folder" || true)
            deleted=$(git diff --name-status HEAD~1 HEAD | grep "^D" | grep "$folder" || true)

            changelog="Added:\n${added}\n\nModified:\n${modified}\n\nDeleted:\n${deleted}"
            gh release edit "$tag" --notes "Automated firmware release for $folder (v${version})." || true
          done

      - name: Delete releases for removed firmware folders
        if: steps.detect.outputs.deleted != ''
        env:
          DELETED: ${{ steps.detect.outputs.deleted }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          for folder in $DELETED; do
            [ -z "$folder" ] && continue
            tags=$(gh release list --limit 1000 --json tagName --jq '.[] | .tagName' | grep "^${folder}-v" || true)
            for tag in $tags; do
              echo "Deleting release and tag: $tag"
              gh release delete "$tag" --yes || true
              git tag -d "$tag" || true
              git push origin :refs/tags/"$tag" || true
            done
          done
