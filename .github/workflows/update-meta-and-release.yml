name: Update Meta and Create Firmware Release

on:
  push:
    branches:
      - main
    paths:
      - "**/*"

permissions:
  contents: write

jobs:
  update-meta:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: pip install pyyaml google-cloud-storage

      - name: Setup Google Cloud credentials from individual keys
        env:
          STORAGE_PRIVATE_KEY: ${{ secrets.STORAGE_PRIVATE_KEY }}
          STORAGE_PROJECT_ID: ${{ secrets.STORAGE_PROJECT_ID }}
          STORAGE_CLIENT_EMAIL: ${{ secrets.STORAGE_CLIENT_EMAIL }}
        run: |
          # Only create credentials if STORAGE_PRIVATE_KEY is set
          if [ -n "$STORAGE_PRIVATE_KEY" ]; then
            cat > /tmp/gcs-key.json <<EOF
          {
            "type": "service_account",
            "project_id": "$STORAGE_PROJECT_ID",
            "private_key": "$STORAGE_PRIVATE_KEY",
            "client_email": "$STORAGE_CLIENT_EMAIL",
            "token_uri": "https://oauth2.googleapis.com/token"
          }
          EOF
            echo "GOOGLE_APPLICATION_CREDENTIALS=/tmp/gcs-key.json" >> $GITHUB_ENV
            echo "GCS credentials configured from individual keys"
          else
            echo "STORAGE_PRIVATE_KEY not set, skipping individual key setup"
          fi

      - name: Authenticate to Google Cloud (JSON key)
        env:
          GCP_CREDS: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
        run: |
          # Only authenticate if JSON key is provided and individual keys weren't already set
          if [ -n "$GCP_CREDS" ] && [ ! -f "/tmp/gcs-key.json" ]; then
            echo "$GCP_CREDS" > /tmp/gcp-key.json
            echo "GOOGLE_APPLICATION_CREDENTIALS=/tmp/gcp-key.json" >> $GITHUB_ENV
            echo "GCS credentials configured from complete JSON key"
          else
            echo "Using individual credentials or GCP_SERVICE_ACCOUNT_KEY not set"
          fi

      - name: Check for unauthorized firmware folder deletions
        id: protect_deletion
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Checking for deleted firmware folders..."

          # Get deleted folders (not just files)
          deleted_items=$(git diff --name-status HEAD~1 HEAD | grep "^D" || true)

          if [ -z "$deleted_items" ]; then
            echo "No deletions detected."
            echo "has_deletions=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Extract deleted firmware folders
          deleted_folders=()
          while read status path; do
            [ -z "$path" ] && continue
            folder=$(echo "$path" | cut -d'/' -f1)

            # Skip non-firmware / system files
            case "$folder" in
              .* | LICENSE | README* ) continue ;;
            esac

            # Check if entire folder is being deleted (no longer exists)
            if [ ! -d "$folder" ]; then
              deleted_folders+=("$folder")
            fi
          done <<< "$deleted_items"

          # Remove duplicates
          deleted_folders=($(printf '%s\n' "${deleted_folders[@]}" | sort -u))

          if [ ${#deleted_folders[@]} -eq 0 ]; then
            echo "No firmware folder deletions detected."
            echo "has_deletions=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Detected deleted folders: ${deleted_folders[*]}"

          # Check the permission of the user who made the commit
          commit_author="${{ github.event.head_commit.author.name }}"
          commit_email="${{ github.event.head_commit.author.email }}"
          repo_owner="${{ github.repository_owner }}"
          actor="${{ github.actor }}"

          echo "Commit author: $commit_author"
          echo "Actor: $actor"
          echo "Repository owner: $repo_owner"

          # Check if actor is repo owner or admin
          user_permission=$(gh api repos/${{ github.repository }}/collaborators/$actor/permission --jq '.permission' 2>/dev/null || echo "none")

          echo "User permission level: $user_permission"

          # Allow deletion only for admin or owner
          if [[ "$user_permission" == "admin" ]] || [[ "$actor" == "$repo_owner" ]]; then
            echo "User $actor has admin/owner permissions. Allowing folder deletion."
            echo "has_deletions=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Unauthorized deletion - revert it
          echo "UNAUTHORIZED: User $actor attempted to delete firmware folders without admin permissions!"
          echo "Reverting deleted folders: ${deleted_folders[*]}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Restore deleted folders from previous commit
          for folder in "${deleted_folders[@]}"; do
            if [ -n "$folder" ]; then
              echo "Restoring folder: $folder"
              git checkout HEAD~1 -- "$folder" || true
            fi
          done

          # Commit the restoration
          git add --all
          if ! git diff --cached --quiet; then
            git commit -m "Revert unauthorized firmware folder deletion by $actor - Deleted folders restored: ${deleted_folders[*]} - Only repository admins/owners can delete firmware folders."
            git push origin main
            echo "Folders restored and pushed."
          fi

          echo "has_deletions=true" >> $GITHUB_OUTPUT
          exit 1

      - name: Detect changed firmware folders and files
        id: detect
        run: |
          git diff --name-status HEAD~1 HEAD > /tmp/changed_files.txt || true
          > /tmp/firmware_folders.txt

          while read status path; do
            [ -z "$path" ] && continue
            top=$(echo "$path" | cut -d'/' -f1)

            # Skip non-firmware / system files
            case "$top" in
              .* | LICENSE | README* ) continue ;;
            esac

            if [ -d "$top" ]; then
              echo "$top" >> /tmp/firmware_folders.txt
            fi
          done < /tmp/changed_files.txt

          sort -u /tmp/firmware_folders.txt -o /tmp/firmware_folders.txt
          folders=$(cat /tmp/firmware_folders.txt | tr '\n' ' ')
          echo "folders=$folders" >> $GITHUB_OUTPUT

      - name: Check for unauthorized meta.yaml edits
        id: protect
        run: |
          echo "Checking for manually edited meta.yaml files..."
          edited_meta=$(git diff --name-status HEAD~1 HEAD | grep "meta.yaml" || true)

          if [ -z "$edited_meta" ]; then
            echo "no_meta_edit=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          unauthorized_files=()
          while read status file; do
            [ -z "$file" ] && continue

            # Skip if folder was deleted entirely
            folder=$(dirname "$file" | cut -d'/' -f1)
            if [ "$status" = "D" ] && [ ! -d "$folder" ]; then
              echo "Skipping revert for deleted folder $folder"
              continue
            fi

            author=$(git log -1 --pretty=format:'%an' -- "$file" || true)
            if [ "$author" != "github-actions[bot]" ]; then
              unauthorized_files+=("$file")
            fi
          done <<< "$edited_meta"

          if [ ${#unauthorized_files[@]} -eq 0 ]; then
            echo "no_meta_edit=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          for f in "${unauthorized_files[@]}"; do
            folder=$(dirname "$f" | cut -d'/' -f1)
            if [ -d "$folder" ]; then
              echo "Reverting unauthorized edit in $f"
              git checkout HEAD~1 -- "$f" || true
            else
              echo "Skipping revert â€” $folder was deleted."
            fi
          done

          # Check if ONLY meta.yaml was changed (no firmware file changes)
          non_meta=$(git diff --name-only HEAD~1 HEAD | grep -v "meta.yaml" || true)
          if [ -z "$non_meta" ]; then
            echo "only_meta_edit=true" >> $GITHUB_OUTPUT
          else
            echo "only_meta_edit=false" >> $GITHUB_OUTPUT
          fi

      - name: Stop pipeline if only meta.yaml was edited manually
        if: steps.protect.outputs.only_meta_edit == 'true'
        run: |
          echo "Unauthorized meta.yaml edit detected."
          echo "Reverted to previous version. No update or release will be created."
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add --all
          git commit -m "Revert unauthorized meta.yaml edit" || true
          git push origin main || true
          exit 0

      - name: Update meta.yaml files and create zip archives
        if: steps.detect.outputs.folders != '' && steps.protect.outputs.only_meta_edit != 'true'
        env:
          FOLDERS: ${{ steps.detect.outputs.folders }}
          GCS_BUCKET_NAME: ${{ vars.GCS_BUCKET_NAME }}
          GCS_FOLDER_PATH: ${{ vars.GCS_FOLDER_PATH }}
          STORAGE_MEDIA_BUCKET: ${{ secrets.STORAGE_MEDIA_BUCKET }}
        run: |
          import os, yaml, datetime, subprocess, sys, zipfile

          folders = os.environ.get("FOLDERS", "").split()
          if not folders or folders == ['']:
              sys.exit(0)

          # Google Cloud Storage setup
          # Support both GCS_BUCKET_NAME (variable) or STORAGE_MEDIA_BUCKET (secret)
          gcs_bucket_name = os.environ.get("GCS_BUCKET_NAME", "") or os.environ.get("STORAGE_MEDIA_BUCKET", "")
          gcs_folder_path = os.environ.get("GCS_FOLDER_PATH", "firmware")
          gcs_enabled = bool(gcs_bucket_name)

          storage_client = None
          bucket = None

          if gcs_enabled:
              try:
                  from google.cloud import storage
                  storage_client = storage.Client()
                  bucket = storage_client.bucket(gcs_bucket_name)
                  print(f"Google Cloud Storage enabled: {gcs_bucket_name}/{gcs_folder_path}")
              except Exception as e:
                  print(f"Warning: GCS setup failed: {e}")
                  gcs_enabled = False

          for folder in folders:
              if not os.path.isdir(folder):
                  print(f"Skipping {folder} (not a directory)")
                  continue

              meta_path = os.path.join(folder, "meta.yaml")
              data = {}
              if os.path.exists(meta_path):
                  with open(meta_path) as f:
                      data = yaml.safe_load(f) or {}

              current_version = float(data.get("version", 0))
              # Start new folders at version 1.0, increment existing by 0.1
              if current_version == 0:
                  version = 1.0
              else:
                  version = round(current_version + 0.1, 1)

              now_utc = datetime.datetime.now(datetime.timezone.utc).isoformat()

              # Create zip file name
              zip_filename = f"{folder}.zip"
              zip_path = os.path.join(folder, zip_filename)

              # Remove old zip file if it exists (local and GCS)
              if os.path.exists(zip_path):
                  os.remove(zip_path)

              if gcs_enabled and bucket:
                  try:
                      gcs_blob_path = f"{gcs_folder_path}/{folder}/{zip_filename}"
                      blob = bucket.blob(gcs_blob_path)
                      if blob.exists():
                          blob.delete()
                          print(f"Deleted old zip from GCS: https://storage.googleapis.com/{gcs_bucket_name}/{gcs_blob_path}")
                  except Exception as e:
                      print(f"Warning: Failed to delete old GCS file: {e}")

              # Create new zip file containing all files in the folder except the zip itself
              print(f"Creating zip archive: {zip_path}")
              with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                  for root, dirs, files in os.walk(folder):
                      # Skip git directories
                      dirs[:] = [d for d in dirs if not d.startswith('.git')]

                      for file in files:
                          # Skip the zip file itself and git-related files
                          if file == zip_filename or file.startswith('.git'):
                              continue

                          file_path = os.path.join(root, file)
                          arcname = os.path.relpath(file_path, folder)
                          zipf.write(file_path, arcname)

              # Upload to Google Cloud Storage
              gcs_url = ""
              if gcs_enabled and bucket:
                  try:
                      gcs_blob_path = f"{gcs_folder_path}/{folder}/{zip_filename}"
                      blob = bucket.blob(gcs_blob_path)
                      blob.upload_from_filename(zip_path)
                      gcs_url = f"https://storage.googleapis.com/{gcs_bucket_name}/{gcs_blob_path}"
                      print(f"Uploaded to GCS: {gcs_url}")
                  except Exception as e:
                      print(f"Warning: Failed to upload to GCS: {e}")

              # Update meta.yaml
              data.update({
                  "version": version,
                  "last_updated": now_utc,
                  "last_commit": subprocess.getoutput("git rev-parse HEAD"),
                  "folder": folder,
                  "zip_file": zip_filename
              })

              if gcs_url:
                  data["gcs_url"] = gcs_url

              with open(meta_path, "w") as f:
                  yaml.dump(data, f)

              print(f"Updated {meta_path} -> version {version}")
              print(f"Created {zip_path}")

        shell: python

      - name: Commit and push updated meta.yaml (if any)
        if: steps.protect.outputs.only_meta_edit != 'true'
        run: |
          if ls */meta.yaml 1> /dev/null 2>&1; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add --all
            if git diff --cached --quiet; then
              echo "No changes to commit."
            else
              git commit -m "Auto-update meta.yaml"
              git push origin main
            fi
          else
            echo "No meta.yaml files found; skipping commit."
          fi

      - name: Fetch latest changes with updated meta.yaml
        if: steps.detect.outputs.folders != '' && steps.protect.outputs.only_meta_edit != 'true'
        run: |
          git fetch origin main
          git reset --hard origin/main

      - name: Create or update GitHub releases per firmware
        if: steps.detect.outputs.folders != '' && steps.protect.outputs.only_meta_edit != 'true'
        env:
          FOLDERS: ${{ steps.detect.outputs.folders }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          for folder in $FOLDERS; do
            [ ! -d "$folder" ] && continue

            # Read the updated version from meta.yaml
            version=$(grep '^version:' "$folder/meta.yaml" | awk '{print $2}')
            tag="${folder}"

            echo "Processing $folder with version $version"

            # Determine changed files inside this folder
            changed_files=$(git diff --name-only HEAD~1 HEAD | grep "^${folder}/" || true)

            if [ -z "$changed_files" ]; then
              files_to_upload="$folder/meta.yaml"
            else
              files_to_upload="$changed_files $folder/meta.yaml"
            fi

            # Check if zip file exists in the folder
            folder_zip="$folder/${folder}.zip"
            if [ -f "$folder_zip" ]; then
              files_to_upload="$files_to_upload $folder_zip"
            fi

            if gh release view "$tag" >/dev/null 2>&1; then
              echo "Release exists; updating assets."
            else
              echo "Creating new release for $folder ($tag)"
              gh release create "$tag" --title "$folder" --notes "Automated release for $folder (v${version})." --target main
            fi

            echo "Uploading assets for $folder..."
            for f in $files_to_upload; do
              if [ -f "$f" ]; then
                gh release upload "$tag" "$f" --clobber || true
              fi
            done

            added=$(git diff --name-status HEAD~1 HEAD | grep "^A" | grep "$folder" || true)
            modified=$(git diff --name-status HEAD~1 HEAD | grep "^M" | grep "$folder" || true)
            deleted=$(git diff --name-status HEAD~1 HEAD | grep "^D" | grep "$folder" || true)

            changelog="Added:\n${added}\n\nModified:\n${modified}\n\nDeleted:\n${deleted}"
            gh release edit "$tag" --notes "Automated firmware release for $folder (v${version})." || true
          done
