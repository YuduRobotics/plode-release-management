name: Update Meta and Create Firmware Release

on:
  push:
    branches:
      - main
    paths:
      - "**/*"

permissions:
  contents: write

jobs:
  update-meta:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: pip install pyyaml

      - name: Detect changed firmware folders and files
        id: detect
        run: |
          git diff --name-status HEAD~1 HEAD > /tmp/changed_files.txt || true
          > /tmp/firmware_folders.txt

          while read status path; do
            [ -z "$path" ] && continue
            top=$(echo "$path" | cut -d'/' -f1)

            # Skip non-firmware / system files
            case "$top" in
              .* | LICENSE | README* ) continue ;;
            esac

            if [ -d "$top" ]; then
              echo "$top" >> /tmp/firmware_folders.txt
            fi
          done < /tmp/changed_files.txt

          sort -u /tmp/firmware_folders.txt -o /tmp/firmware_folders.txt
          folders=$(cat /tmp/firmware_folders.txt | tr '\n' ' ')
          echo "folders=$folders" >> $GITHUB_OUTPUT

      - name: Check for unauthorized meta.yaml edits
        id: protect
        run: |
          echo "Checking for manually edited meta.yaml files..."
          edited_meta=$(git diff --name-only HEAD~1 HEAD | grep "meta.yaml" || true)

          if [ -z "$edited_meta" ]; then
            echo "no_meta_edit=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          unauthorized_files=()
          for f in $edited_meta; do
            author=$(git log -1 --pretty=format:'%an' -- "$f" || true)
            if [ "$author" != "github-actions[bot]" ]; then
              unauthorized_files+=("$f")
            fi
          done

          if [ ${#unauthorized_files[@]} -eq 0 ]; then
            echo "no_meta_edit=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          for f in "${unauthorized_files[@]}"; do
            echo "Reverting unauthorized edit in $f"
            git checkout HEAD~1 -- "$f" || true
          done

          # Check if ONLY meta.yaml was changed (no firmware file changes)
          non_meta=$(git diff --name-only HEAD~1 HEAD | grep -v "meta.yaml" || true)
          if [ -z "$non_meta" ]; then
            echo "only_meta_edit=true" >> $GITHUB_OUTPUT
          else
            echo "only_meta_edit=false" >> $GITHUB_OUTPUT
          fi

      - name: Stop pipeline if only meta.yaml was edited manually
        if: steps.protect.outputs.only_meta_edit == 'true'
        run: |
          echo "Unauthorized meta.yaml edit detected."
          echo "Reverted to previous version. No update or release will be created."
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add --all
          git commit -m "Revert unauthorized meta.yaml edit" || true
          git push origin main || true
          exit 0

      - name: Update meta.yaml files
        if: steps.detect.outputs.folders != '' && steps.protect.outputs.only_meta_edit != 'true'
        env:
          FOLDERS: ${{ steps.detect.outputs.folders }}
        run: |
          import os, yaml, datetime, subprocess, sys

          folders = os.environ.get("FOLDERS", "").split()
          if not folders or folders == ['']:
              sys.exit(0)

          for folder in folders:
              if not os.path.isdir(folder):
                  print(f"Skipping {folder} (not a directory)")
                  continue

              meta_path = os.path.join(folder, "meta.yaml")
              data = {}
              if os.path.exists(meta_path):
                  with open(meta_path) as f:
                      data = yaml.safe_load(f) or {}

              version = float(data.get("version", 0))
              version = round(version + 0.1, 1)

              now_utc = datetime.datetime.now(datetime.timezone.utc).isoformat()
              data.update({
                  "version": version,
                  "last_updated": now_utc,
                  "last_commit": subprocess.getoutput("git rev-parse HEAD"),
                  "folder": folder
              })

              with open(meta_path, "w") as f:
                  yaml.dump(data, f)

              print(f"Updated {meta_path} -> version {version}")

        shell: python

      - name: Commit and push updated meta.yaml (if any)
        if: steps.protect.outputs.only_meta_edit != 'true'
        run: |
          if ls */meta.yaml 1> /dev/null 2>&1; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add --all
            if git diff --cached --quiet; then
              echo "No changes to commit."
            else
              git commit -m "Auto-update meta.yaml"
              git push origin main
            fi
          else
            echo "No meta.yaml files found; skipping commit."
          fi

      - name: Create or update GitHub releases per firmware
        if: steps.detect.outputs.folders != '' && steps.protect.outputs.only_meta_edit != 'true'
        env:
          FOLDERS: ${{ steps.detect.outputs.folders }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          for folder in $FOLDERS; do
            [ ! -d "$folder" ] && continue

            version=$(grep '^version:' "$folder/meta.yaml" | awk '{print $2}')
            tag="${folder}-v${version}"

            # Determine changed files inside this folder
            changed_files=$(git diff --name-only HEAD~1 HEAD | grep "^${folder}/" || true)

            if [ -z "$changed_files" ]; then
              files_to_upload="$folder/meta.yaml"
            else
              files_to_upload="$changed_files $folder/meta.yaml"
            fi

            if gh release view "$tag" >/dev/null 2>&1; then
              echo "Release exists; updating assets."
            else
              echo "Creating new release for $folder ($tag)"
              gh release create "$tag" --title "$folder v${version}" --notes "Automated release for $folder (v${version})." --target main
            fi

            echo "Uploading changed assets for $folder..."
            for f in $files_to_upload; do
              if [ -f "$f" ]; then
                gh release upload "$tag" "$f" --clobber || true
              fi
            done

            added=$(git diff --name-status HEAD~1 HEAD | grep "^A" | grep "$folder" || true)
            modified=$(git diff --name-status HEAD~1 HEAD | grep "^M" | grep "$folder" || true)
            deleted=$(git diff --name-status HEAD~1 HEAD | grep "^D" | grep "$folder" || true)

            changelog="Added:\n${added}\n\nModified:\n${modified}\n\nDeleted:\n${deleted}"
            gh release edit "$tag" --notes "Automated firmware release for $folder (v${version})." || true
          done

      - name: Delete releases for removed firmware folders
        if: steps.detect.outputs.deleted != ''
        env:
          DELETED: ${{ steps.detect.outputs.deleted }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          for folder in $DELETED; do
            [ -z "$folder" ] && continue
            tags=$(gh release list --limit 1000 --json tagName --jq '.[] | .tagName' | grep "^${folder}-v" || true)
            for tag in $tags; do
              echo "Deleting release and tag: $tag"
              gh release delete "$tag" --yes || true
              git tag -d "$tag" || true
              git push origin :refs/tags/"$tag" || true
            done
          done
